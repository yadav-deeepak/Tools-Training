###############################
ğŸ³ What is Docker?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Docker is an open-source platform that allows developers to build, package, and run applications inside containers.
â¤ A container is a lightweight, standalone environment that includes everything needed to run a piece of software â€” like code, libraries, dependencies, and configuration files.
â¤ It ensures that your application runs consistently across different environments, whether on a developerâ€™s laptop, a test server, or in production.

ğŸ‘‰ In simple terms:
Docker = A tool that helps developers run their apps anywhere without worrying about â€œit works on my machineâ€ problems ğŸ˜…

âš™ï¸ Why Do We Need Docker?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ 1. Consistency Across Environments
**************************************
ğŸ‘‰ Docker ensures the app behaves the same on every machine (no dependency conflicts).

â¤ 2. Lightweight and Fast
***************************
ğŸ‘‰ Containers share the host OS kernel, so they start instantly and use fewer resources compared to Virtual Machines.

â¤ 3. Easier Deployment
*************************
ğŸ‘‰ You can bundle (containerize) your app and deploy it easily to any environment â€” cloud, on-prem, or hybrid.

â¤ 4. Simplified Dependency Management
***************************************
ğŸ‘‰ No need to install complex libraries or tools on every system; everything is inside the container.

â¤ 5. Scalability and Microservices Support
*********************************************
ğŸ‘‰ Docker makes it easy to scale services up/down and is ideal for microservices-based architecture.

â¤ 6. Better Collaboration
***************************
ğŸ‘‰ Teams can share containers using Docker Hub, ensuring everyone runs the same version of the app.

ğŸ§  Example:
=============
If you have a Java web app that needs Tomcat + MySQL,
instead of installing them manually on every system,
you can create a Docker container with both preconfigured â€”
then anyone can run it using just one command:

docker run my-java-app

##############################
ğŸ—ï¸ Docker Architecture
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â¤ Docker follows a client-server architecture consisting of three main components:
1ï¸âƒ£ Docker Client
2ï¸âƒ£ Docker Daemon (Server)
3ï¸âƒ£ Docker Objects (Images, Containers, Volumes, Networks)

Letâ€™s understand each part in detail ğŸ‘‡

ğŸš 1ï¸âƒ£ Docker Client (CLI / Docker Command Line)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ The Docker Client is what users interact with.
â¤ It sends commands (like docker build, docker run, docker pull, etc.) to the Docker Daemon using REST APIs.
â¤ The client can communicate with local or remote Docker Daemons.

ğŸ‘‰ Example:
When you run â€”

docker run nginx

â¤ This command is sent from Docker Client â†’ Docker Daemon, which then creates and starts a container for nginx.

âš™ï¸ 2ï¸âƒ£ Docker Daemon (dockerd)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ The Docker Daemon runs in the background and handles all container-related tasks.
â¤ It is responsible for:
ğŸ‘‰ Building Docker images ğŸ§±
ğŸ‘‰ Running and managing containers ğŸš€
ğŸ‘‰ Handling Docker objects like networks and volumes ğŸ”—
â¤ It listens for API requests from the Docker Client.

ğŸ‘‰ You can think of it as the â€œbrainâ€ of Docker that does all the heavy lifting.

ğŸ“¦ 3ï¸âƒ£ Docker Objects
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Docker uses several objects to function:

â¤ a. Docker Image
********************
ğŸ‘‰ A template or blueprint used to create containers.
ğŸ‘‰ It contains the app code + runtime + dependencies.
Example: nginx:latest, mysql:8, etc.

â¤ b. Docker Container
***********************
ğŸ‘‰ A running instance of a Docker Image.
ğŸ‘‰ Containers are isolated but can communicate through Docker networks.
ğŸ‘‰ You can start, stop, move, or delete containers easily.

â¤ c. Docker Volumes
**********************
ğŸ‘‰ Used for data persistence (data not lost when a container stops).
ğŸ‘‰ Example: storing database files outside the container.

â¤ d. Docker Networks
*********************
ğŸ‘‰ Allow multiple containers to communicate with each other securely.

ğŸŒ 4ï¸âƒ£ Docker Registry (e.g., Docker Hub)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ A repository that stores Docker images.
â¤ You can push your own images or pull public ones.
ğŸ‘‰ Example: docker pull ubuntu downloads the Ubuntu image from Docker Hub.

ğŸ§© ğŸ–¼ï¸ Visual Flow of Docker Architecture:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

+-------------------------------+
|       Docker Client (CLI)     |
|    (docker build/run/pull)    |
+---------------+---------------+
                |
                v
+--------------------------------+
|        Docker Daemon (dockerd) |
|  - Manages images & containers  |
|  - Handles API requests         |
+----------------+----------------+
                |
        +-------+-------+
        |               |
        v               v
+-------------+   +-------------+
|   Registry  |   | Docker Host |
| (DockerHub) |   | (Images,    |
|             |   | Containers) |
+-------------+   +-------------+


âš¡ Summary Table:
******************
#################################################################################
| Component        | Description                           | Example            |
| ---------------- | ------------------------------------- | ------------------ |
| Docker Client    | Sends commands                        | `docker run nginx` |
| Docker Daemon    | Executes commands, manages containers | Background service |
| Docker Image     | Template for containers               | `python:3.9`       |
| Docker Container | Running instance of image             | A live app         |
| Docker Registry  | Stores and shares images              | Docker Hub         |
#################################################################################

######################################
ğŸ“¦ Containerization vs Dockerization
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Letâ€™s understand these two important terms â€” they are often used together but mean slightly different things ğŸ‘‡

ğŸ§± 1ï¸âƒ£ Containerization
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Definition:
***************
Containerization is the process of packaging an application and all its dependencies (libraries, frameworks, configuration files, etc.) into a single lightweight unit called a container.

â¤ Purpose:
************
To make sure the app runs consistently across different environments â€” development, testing, and production.

â¤ How it works:
*****************
ğŸ‘‰ Each container runs as an isolated process on the host OS but shares the same OS kernel.
ğŸ‘‰ This makes containers lightweight and fast compared to Virtual Machines.

â¤ Key Benefits:
*****************
ğŸ‘‰ Portability ğŸ§³ â†’ Run anywhere
ğŸ‘‰ Isolation ğŸ”’ â†’ Each app runs in its own environment
ğŸ‘‰ Efficiency âš¡ â†’ Uses less memory and CPU than VMs

â¤ Example:
If you package a Java app with Tomcat and MySQL into separate containers, those containers can run on any system that supports containerization â€” no manual setup needed.

ğŸ³ 2ï¸âƒ£ Dockerization
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Definition:
**************
Dockerization is the implementation of containerization using Docker.
In simple terms â€” itâ€™s the process of creating, deploying, and running containers using Docker tools.

â¤ Steps Involved in Dockerization:
************************************
ğŸ‘‰ Step 1: Write a Dockerfile (blueprint of your container)
ğŸ‘‰ Step 2: Build an image using that file â†’ docker build -t myapp .
ğŸ‘‰ Step 3: Run a container â†’ docker run myapp

â¤ Purpose:
***********
To automate and simplify the process of containerization using Docker commands and Docker Engine.

â¤ Example:
If you â€œdockerizeâ€ your Node.js app, it means youâ€™ve created a Docker image and can run it anywhere using Docker.

âš¡ ğŸ§  Key Difference Table
*****************************
#############################################################################################################################
| Feature       | Containerization                                   | Dockerization                                        |
| ------------- | -------------------------------------------------- | ---------------------------------------------------- |
| **Meaning**   | Concept of packaging apps into containers          | Implementation of containerization using Docker      |
| **Tool Used** | Any container platform (Docker, Podman, LXC, etc.) | Specifically uses Docker                             |
| **Focus**     | Application packaging & isolation                  | Building and running containers using Docker         |
| **Example**   | Running multiple containers on Kubernetes          | Creating a Dockerfile and running `docker run myapp` |
#############################################################################################################################

ğŸ’¬ In Simple Words:
*********************
â¤ Containerization â†’ The concept
â¤ Dockerization â†’ The practice (using Docker)

############################################################
ğŸŒ Creating and Running a Docker Image (Access via Browser)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Letâ€™s break this into clear and structured notes ğŸ‘‡

ğŸ³ 1ï¸âƒ£ Running Docker Image from Docker Hub
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Command:

docker run image-name

ğŸ‘‰ This command downloads the image (if not present locally) and runs it as a container.

âš ï¸ Issue:
â¤ You cannot access the app in your browser directly because no port mapping is done yet.

ğŸ§© 2ï¸âƒ£ Why Port Mapping is Needed?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Containers run in isolated environments with their own internal network.
â¤ To access the app from your host machine (browser), you must connect the host port to the containerâ€™s internal port.
â¤ This process is called Port Mapping.

ğŸ”— 3ï¸âƒ£ Port Mapping Command
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Syntax:

docker run -p host-port:container-port image-name

â¤ Meaning:
ğŸ‘‰ The host-port is the port on your system (or Linux VM).
ğŸ‘‰ The container-port is the port exposed by the application inside the container.

ğŸ§  Example:
-------------
docker run -p 9090:9090 image-name

ğŸ‘‰ Maps host port 9090 to container port 9090
ğŸ‘‰ Now, the app can be accessed from your browser at:

http://<public-ip>:9090

âš™ï¸ 4ï¸âƒ£ Running Container in the Background (Detached Mode)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ If you want the container to keep running even after closing the terminal ğŸ‘‡

docker run -d -p 9091:9090 image-name

ğŸ‘‰ -d = detached mode (runs in background)
ğŸ‘‰ You can continue using the terminal while the container runs.

ğŸ›‘ 5ï¸âƒ£ Stopping a Running Container
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ To stop the container:

docker stop container-id

ğŸ‘‰ You can find the container ID using:

docker ps

ğŸ§± 6ï¸âƒ£ Important Notes
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ If you run multiple containers on the same VM, each must have a different host port.
ğŸ‘‰ Example:

docker run -d -p 8080:9090 image1
docker run -d -p 8081:9090 image2

â¤ Ensure inbound rules in your security group/firewall allow traffic on the chosen host port (e.g., 8080, 9090).
ğŸ‘‰ Set Custom TCP Rule â†’ Port = host port â†’ Source = Anywhere (IPv4)

âœ… Summary Table
******************
###########################################################################################################################
| Task                    | Command                                      | Description                                    |
| ----------------------- | -------------------------------------------- | ---------------------------------------------- |
| Run container           | `docker run image-name`                      | Starts container but not accessible in browser |
| Run with port mapping   | `docker run -p host:container image-name`    | Maps ports for browser access                  |
| Run in background       | `docker run -d -p host:container image-name` | Keeps container running after terminal close   |
| View running containers | `docker ps`                                  | Lists active containers                        |
| Stop container          | `docker stop container-id`                   | Stops a running container                      |
###########################################################################################################################

################################
ğŸš€ Advantages of Docker Images
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â¤ A Docker Image is the blueprint of a container â€” it defines what the container will look like and how it will run.
It contains everything needed for an application: code, libraries, dependencies, configuration, and runtime environment.

Letâ€™s see why Docker images are so powerful ğŸ‘‡

ğŸ—ï¸ 1ï¸âƒ£ Portability
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Docker images can run anywhere â€” on your local system, a cloud server, or a CI/CD pipeline.
ğŸ‘‰ This ensures that the application behaves the same across all environments (no â€œit works on my systemâ€ issues ğŸ˜…).

ğŸ§  Example:
You can build an image on your laptop and run it on AWS, GCP, or Azure without any modification.

âš™ï¸ 2ï¸âƒ£ Consistency & Reliability
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ The image contains the complete environment setup â€” OS libraries, frameworks, app code, etc.
ğŸ‘‰ So, you always get the same behavior no matter where or how often you deploy it.

ğŸ§± Example:
A Java app inside an image will always have the same JDK version, Tomcat setup, and configuration every time it runs.

âš¡ 3ï¸âƒ£ Lightweight and Fast Deployment
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Images are layered and cached, so only changed layers are rebuilt.
ğŸ‘‰ This makes building and deploying much faster compared to traditional VMs.
ğŸ‘‰ Also consumes less disk space and system memory.

ğŸ§© Example:
If you update one line of code, Docker only rebuilds that part instead of the entire environment.

ğŸ” 4ï¸âƒ£ Version Control for Environments
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Docker images can be versioned and tagged just like Git commits.
ğŸ‘‰ Example:

myapp:v1
myapp:v2


You can easily roll back to a previous version if needed.

ğŸ§³ 5ï¸âƒ£ Easy Distribution and Sharing
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Images can be pushed to registries (like Docker Hub, AWS ECR, etc.) and shared with teammates or other systems.
ğŸ‘‰ This makes collaboration and deployment super easy.

ğŸ§  Example:
Push your app image to Docker Hub â†’ your teammate can pull and run it instantly.

ğŸ§± 6ï¸âƒ£ Reusability and Modularity
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Images can be built on top of other base images.
ğŸ‘‰ This allows modular design â€” reuse existing OS or language images like ubuntu, node, python, etc.

ğŸ§  Example:
You can create your custom image based on:

FROM openjdk:17


and then add your Java app â€” no need to set up JDK manually.

ğŸ§© 7ï¸âƒ£ Simplifies CI/CD Pipeline
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Docker images make Continuous Integration and Deployment smooth.
ğŸ‘‰ The same image can be tested, deployed, and scaled in production automatically.

ğŸ”’ 8ï¸âƒ£ Security and Isolation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Each image runs in its own isolated environment, reducing the risk of conflicts or dependency issues.

âœ… Summary Table
*****************
###################################################################
| Advantage       | Description                                   |
| --------------- | --------------------------------------------- |
| Portability     | Run anywhere â€” same behavior on all platforms |
| Consistency     | Fixed environment setup inside image          |
| Lightweight     | Fast build and low resource usage             |
| Version Control | Tag and roll back to older versions           |
| Easy Sharing    | Push/pull from Docker Hub                     |
| Reusability     | Build on existing base images                 |
| CI/CD Friendly  | Seamless integration into pipelines           |
| Secure          | Isolated environment per container            |
###################################################################

#########################################
ğŸ“ Dockerfile â€“ How to Create & Use It
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ A Dockerfile is a script containing a set of instructions to build a Docker Image.
Each instruction is executed top to bottom while building the image.
â¤ Dockerfile instructions are UPPERCASE and case-sensitive.

ğŸŒŸ FROM
*********
â¤ The FROM instruction specifies the base image on which your application will run.
â¤ It should always be the first instruction.
â¤ Used to define required software/runtime environment.

Syntax:
-------
FROM <image>:<tag>

Examples:
â¤ FROM openjdk:21
â¤ FROM eclipse-temurin:17-jdk (âœ” recommended â†’ OpenJDK images deprecated)
â¤ FROM mysql:8.0

ğŸŒŸ MAINTAINER (Deprecated)
***************************
â¤ Specifies the maintainer of the image.
â¤ Deprecated since Docker 1.13 â†’ Use LABEL instead.

ğŸŒŸ RUN
********
â¤ Used to execute commands during image build time.
â¤ Useful for installing packages, configurations, etc.

Examples:
----------
RUN git clone <repo-url>  
RUN mvn clean package

â¤ Multiple RUN commands execute sequentially.

ğŸŒŸ CMD
*********
â¤ Specifies the default command to run when the container starts.
â¤ If multiple CMDs exist â†’ Only the last one runs.
â¤ Can be overridden during docker run.

Example:
---------
CMD "java -jar myapp.jar"

ğŸ›‘ CMD Override Example:
========================
docker run image-id echo "hello world"

â†’ This overrides CMD and runs hello world instead.

ğŸŒŸ ENTRYPOINT
**************
â¤ Works like CMD but cannot be overridden.
â¤ Use ENTRYPOINT when you want your main process to always run.

Example:
---------
ENTRYPOINT ["java", "-jar", "app.jar"]

ğŸŒŸ COPY
*********
â¤ Copies files/folders from Host Machine â†’ Container.
â¤ Used to copy application source or JAR files.

Example:
--------
COPY target/your-app.jar /usr/app/

ğŸŒŸ ADD
********
â¤ Similar to COPY, but with extra features:
â¤ Can extract tar files automatically
â¤ Can copy from host machine
â¤ âŒ Cannot download from URL (common interview trap)

Example:
--------
ADD target/app.jar /usr/app/

âŒ ADD https://file.com/file.jar /usr/app/ â†’ Not allowed

ğŸŒŸ WORKDIR
************
â¤ Sets the working directory for subsequent commands (like cd).
â¤ If the folder does not exist, Docker creates it automatically.

Example:
---------
WORKDIR /usr/app/
CMD "java -jar your-app.jar"

ğŸŒŸ EXPOSE
***********
â¤ Just documents the port your application runs on.
â¤ Does NOT map ports â†’ That is done using docker run -p.

Example:
----------
EXPOSE 9090

âš ï¸ If your app runs on 8081 and you write EXPOSE 9090, it is wrong.

##############################################
ğŸ”§ How to Create a Dockerfile (Step-by-Step)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Step 1 â€” Create a Dockerfile
********************************
vi Dockerfile

Example Dockerfile:
-------------------
FROM eclipse-temurin:17-jdk
LABEL maintainer="Pankaj"
RUN echo 'run-1'
RUN echo 'run-2'
CMD echo 'cmd-1'
CMD echo 'cmd-2'

Step 2 â€” Build the Docker Image
********************************
docker build -t pankajsiracademy/image1 .

â¤ Dot (.) means Dockerfile is in the current directory.

â¤ Step 3 â€” Check Created Images
*********************************
docker images

â¤ Step 4 â€” Delete Image
*************************
docker rmi image-id

â¤ Step 5 â€” Rebuild the Image
*******************************
docker build -t pankajsiracademy/image1 .

â¤ Step 6 â€” Run the Docker Image
*********************************
docker run image-id

ğŸ›‘ Important Notes
===================
â¤ Only the last CMD in the Dockerfile executes.
â¤ CMD can be overridden using:

docker run image-id <command>

â¤ To prevent override â†’ Use ENTRYPOINT.

############################################
ğŸš€ Dockerizing a Spring Boot Application
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Spring Boot is a framework used to build enterprise-level applications.
â¤ Spring Boot applications are packaged as JAR files for deployment.
â¤ To run a Spring Boot JAR, we use:

java -jar <filename>.jar

â¤ Spring Boot uses an embedded Tomcat server.
â¤ By default, a Spring Boot app runs on port 8080.

ğŸ“ JAR Name Using pom.xml
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ In pom.xml, inside <build> section, use <finalName> to specify the jar name:

<build>
    <finalName>demo-app</finalName> 
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>


â¤ This ensures your jar name becomes:
â¡ demo-app.jar

ğŸ§± Step 1: Create Dockerfile
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Place this Dockerfile in the root directory of the Spring Boot project.

FROM eclipse-temurin:17-jdk

COPY target/demo-app.jar /usr/app/

WORKDIR /usr/app/

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "demo-app.jar"]

âœ” FROM â†’ Base JDK
âœ” COPY â†’ Move your jar into container
âœ” WORKDIR â†’ Navigate inside container
âœ” EXPOSE 8080 â†’ Document running port
âœ” ENTRYPOINT â†’ Run the jar inside container

ğŸ§‘â€ğŸ’» Step 2: Install Maven, Git, Docker in Linux VM
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Install Git:

sudo yum install git -y

â¤ Install Maven:

sudo yum install maven -y

â¤ Clone your GitHub repo:

git clone <repo-url>

â¤ Move into the project directory:

cd <app-name>

â¤ Build jar file using maven:

mvn clean package

â¤ Jar will be created under â†’ target/demo-app.jar

ğŸ³ Step 3: Build Docker Image
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

docker build -t dockerusername/repositoryName:<tag> .

Example:
---------
docker build -t psait/pankajsiracademy:prod-v1 .

âœ” Use . to indicate Dockerfile is in the same directory
âœ” Create repo on Docker Hub before pushing
âœ” Tag examples:

prod-v1 â†’ Production
dev-v1 â†’ Development
test-v1 â†’ Testing
staging-v1 â†’ Staging

â¤ Check images:
-----------------
docker images

ğŸš¢ Step 4: Run Docker Container
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

docker run -d -p 8080:8080 --name psa psait/your-app:<tag>

â¤ -d â†’ Run in background
â¤ -p â†’ Port mapping
â¤ --name psa â†’ (Optional) name for your container

âœ” Donâ€™t forget to allow port 8080 in your VM Security Group:
Inbound Rule â†’ Custom TCP â†’ 8080 â†’ Anywhere IPv4
â¤ If you skip this â†’ App wonâ€™t open in browser.

ğŸ” Step 5: Check Running Container
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
docker ps

ğŸ“œ Step 6: View Logs of Container
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
docker logs <container-id>

ğŸŒ Step 7: Access Application in Browser
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
http://<public-ip>:8080/

ğŸ“¤ Steps to Push Docker Image to Docker Hub
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1ï¸âƒ£ Login to Docker Hub
***********************
docker login

Enter:
â¤ Username
â¤ Password

2ï¸âƒ£ Push Image
***************
docker push psait/pankajsiracademy:<tag>

Example:
--------
docker push psait/pankajsiracademy:testing-v1

âœ… Full Process Summary (Quick Revision Sheet)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â¤ Build JAR using Maven
â¤ Create Dockerfile
â¤ Build Docker image
â¤ Push image to Docker Hub
â¤ Run image as container
â¤ Access app via browser